# ruff: noqa: RUF001

from typing import Sequence

from langchain.chains import LLMChain, SimpleSequentialChain
from langchain.chat_models import ChatOpenAI
from langchain.prompts import PromptTemplate
from openai import OpenAI

from notice_api.core.config import settings

OpenAIClient = OpenAI(api_key=settings.OPENAI_API_KEY)

llm = ChatOpenAI(
    model="gpt-3.5-turbo-16k", temperature=0.3, api_key=settings.OPENAI_API_KEY
)

llm_stream = ChatOpenAI(
    model="gpt-3.5-turbo-16k",
    temperature=0.3,
    api_key=settings.OPENAI_API_KEY,
    streaming=True,
)

cleaning_template = """
- Eliminate redundant words from the following raw transcript
- The content of the raw transcript will be marked as such: RAW TRANSCRIPT ```(raw transcript content)```
- Words are considered redundant if it satisfy one of the following conditions:
    - 1. Time stamps
    - 2. Markings or abbriviations which seem to be generated by other speach-to-text/caption services. For example, "WEBVTT"

- RAW TRANSCRIPT ```{raw_transcript}```
"""

note_generation_template = """
- task：Your job is to generate bulletpoint notes from the provided transcript
    - input：
        - the latest transcript
        - the content of the transcript will be marked as such: transcript ```(transcript content)```
    - output：
        - represent the whole trancript content as bulletpoints without lost information
        - the bulletpoints should strictly follow the chronological order of the input transcript
        - output the bulletpoints using markdown
        - each content of the bulletpoints can only be one of the following: a single sentence, keyword(s), words used for formatting
        - a bulletpoint should be less than 60 characters. if it is longer that, split it into multiple sub-bulletpoints
        - sub-bulletpoints have additional tabs in front
        - the whole output should contain at least 1500 characters and be as detailed as possible
        - only output the bulletpoints and sub-bulletpoints texts
        - don't use the example output word for word
        - output format: "
            - <bulletpoint 1>
            - <bulletpoint 2>
                - <sub-bulletpoint 2-1>
                - <sub-bulletpoint 2-2>
                ...
            - <bulletpoint 3>
            ...
        "
        - example output: "
            - Introduction to Algorithms
                - Lecture two
                - Erik Demaine loves algorithms
            - Data Structures
                - Sequences, sets, linked lists, dynamic arrays
                - Simple data structures
                - Beginning of several data structures
            - Interface vs Data Structure
                - Interface specifies what you want to do
                - Data structure specifies how to do it
            - Operations on Data Structures
                - Storing data
                - Specifying operations and their meanings
                - Algorithms for supporting operations
            - Two main interfaces: set and sequence
                - Set: maintaining data in sorted order, searching for a key
                - Sequence: maintaining a particular sequence, storing n things
            - Two main approaches: arrays and pointers
            - Static Sequence Interface
                - Number of items doesn't change
                - Operations: build, length, iteration, get, set
            - Static Array
                - Solution to the static sequence interface problem
                - No static arrays in Python, only dynamic arrays
            - Word RAM model of computation
        "

- transcript ```{transcript}```
"""

check_with_usernote_template = """
- task: Classify if each line in the generated note is mentioned in the user note
    - input:
        - user note: ```(usernote)```
        - generated note: ```(generated_note)```
    - output:
        - output the whole generated note, but at the start of each line, add an indicator that is either <Y> or <N>
        - add <Y> if this line is mentioned in the user note
        - add <N> if this line is NOT mentioned in the user note
        - a line is mentioned in the user note if it is contextually related or can be implied by the user note
        - If classified as <Y>, change it to <N> if this line has sub-points classified as <N>.
        - example output: "
<N> - Static sequence interface
<Y>     - Number of items doesn't change
<N>     - Static array is the natural solution to this interface problem
<Y>         - Data structures can be considered solutions
<N>         - Memory is an array of w-bit words
<Y>     - Operations: build, length, iteration, get, set
                    "

- user note: ```{usernote}```

- generated note: ```{generated_note}```
"""


def generate_note_langchain(transcript: str | Sequence[str], usernote: str) -> str:
    # 去除冗言贅字
    # prompt_template = PromptTemplate(
    #     input_variables=["raw_transcript"], template=cleaning_template
    # )
    # chain1 = LLMChain(llm=llm, prompt=prompt_template)

    # 整理成條列式
    prompt_template = PromptTemplate(
        input_variables=["transcript"], template=note_generation_template
    )
    chain2 = LLMChain(llm=llm, prompt=prompt_template)

    # 這部分你把prompt換成漢字季的筆記對比 我現在先用給我其中三點來測試
    # template1 = """give me three important part in this note
    # % note
    # {note}
    # """
    # prompt_template = PromptTemplate(input_variables=["note"], template=template1)
    # chain3 = LLMChain(llm=llm, prompt=prompt_template)

    # 串起三個部分
    # chain1 跑的時間很久目前先拔掉
    overall_chain = SimpleSequentialChain(chains=[chain2], verbose=True)
    return overall_chain.run("\n".join(transcript))


def generate_note_openai(transcript: str | Sequence[str], usernote: str):
    # 整理成條列式
    note_generation_prompt = note_generation_template.format(
        transcript="\n".join(transcript)
    )
    response = OpenAIClient.chat.completions.create(
        model="gpt-3.5-turbo-16k",
        messages=[{"role": "user", "content": note_generation_prompt}],
        temperature=0.5,
    )
    generated_note = response.choices[0].message.content

    # 與使用者筆記做對照並標記
    check_with_usernote_prompt = check_with_usernote_template.format(
        usernote=usernote, generated_note=generated_note
    )
    response = OpenAIClient.chat.completions.create(
        model="gpt-3.5-turbo-16k",
        messages=[{"role": "user", "content": check_with_usernote_prompt}],
        temperature=0.0,
        stream=True,
    )

    check_string = ""  # 用來檢查目前收到的回應是否書要傳出去
    check_result = "<check result>\n"  # 紀錄完整的模型輸出
    should_yield = False  # 需要回傳
    for chunk in response:
        if chunk.choices[0].delta.content is None:
            # openai 回應結束
            break
        else:
            current_string = chunk.choices[0].delta.content
            check_string += chunk.choices[0].delta.content
            check_result += chunk.choices[0].delta.content

            if (
                check_string.endswith("<")
                or check_string.endswith("<Y")
                or check_string.endswith("<N")
                or check_string.endswith("<Y>")
            ):
                should_yield = False

            if check_string.endswith("<N>"):
                should_yield = True
                check_string = ""
                continue
            elif "<N>" in check_string:
                should_yield = True
                index = check_string.find("<N>")
                rest_of_string = check_string[index + len("<N>") :]
                check_string = ""
                yield rest_of_string
                continue

            if should_yield:
                yield current_string
    yield check_result + "\n"
    # yield (generated_note or '')+'\n'
